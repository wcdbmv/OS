; В защищённом режиме вывод фиксированных символов на экран
.386P				; (1) Разрешение трансляции всех, в том
				; числе привилегированных команд МП 386
				; и 486

; Структура для описания дескрипторов сегментов
descr	struc			; (2)
limit	dw	0		; (3) Граница (биты 0...15)
base_l	dw	0		; (4) База, биты 0...15
base_m	db	0		; (5) База, биты 16...23
attr_1	db	0		; (6) Байт атрибутов 1
attr_2	db	0		; (7) Граница (биты 16...19) и атрибуты 2
base_h	db	0		; (8) База, биты 24...31
descr	ends			; (9)

data	segment	use16		; (10) Начало сегмента данных
; Таблица глобальных дескрипторов GDT
gdt_null descr<0,0,0,0,0,0>		; (11) Селектор 0 — обязательный
					; нулевой дескриптор
gdt_data descr<data_size-1,0,0,92h,0,0>	; (12) Селектор 8, сегмент данных
gdt_code descr<code_size-1,0,0,98h,0,0>	; (13) Селектор 16, сегмент команд
gdt_stack descr<255,0,0,92h,0,0>	; (14) Селектор 24, сегмент стека
gdt_screen descr<4095,8000h,0Bh,92h,0,0>; (15) Селектор 32, видеобуфер
gdt_size=$-gdt_null		; (16) Размер GDT
; Поля данных программы
pdescr	df	0		; (17) Псевдодескриптор для lgdt
real_sp	dw	0		; (18) Ячейка для хранения SP
sym	db	1		; (19) Символ для вывода на экран
attr	db	1Eh		; (20) Его атрибут
mes	db	27,'[31;42m Вернулись в реальный режим! ',27,'[0m$'; (21)
data_size=$-gdt_null		; (22) Размер сегмента данных
data	ends			; (23) Конец сегмента данных

text	segment	'code' use16	; (24) Начало сегмента команд. Будем
				; работать в 16-разрядном режиме
	assume	cs:text,ds:data	; (25)
main	proc			; (26)
	mov	ax,data		; (27) Инициализация реального
	mov	ds,ax		; (28) режима
; Вычислим 32-битовый линейный адрес сегмента данных и загрузим его
; в дескриптор сегмента данных в таблице GDT. В регистре AX уже
; находится сегментный адрес. Умножим его на 16 сдвигом влево на 4
; биты с размещением результата в регистрах DL:AX
	mov	dl,0		; (29)
	shld	dx,ax,4		; (30) Сдвинем биты 12...15 AX в DL
	shl	ax,4		; (31) Сдвинем влево AX на 4 бита
; Теперь в DL:AX 32-битовый линейный адрес сегмента данных
	mov	bx,offset gdt_data; (32) В BX адрес дескриптора
	mov	[bx].base_l,ax	; (33) Загрузим младшую часть базы
	mov	[bx].base_m,dl	; (34) Загрузим среднюю часть базы
; Вычислим 32-битовый линейный адрес сегмента команд и загрузим его
; в дескриптор сегмента команд в таблице глобальных дескрипторов
	mov	ax,cs		; (35) AX=адрес сегмента команд
	mov	dl,0		; (36) Та же процедура умножения
	shld	dx,ax,4		; (37) сегментного адреса на 16
	shl	ax,4		; (38) сдвигом влево на 4 бита
	mov	bx,offset gdt_code; (39) BX=адрес дескриптора
	mov	[bx].base_l,ax	; (40) Загрузка младшей
	mov	[bx].base_m,dl	; (41) и средней частей базы
; Аналогично для адреса сегмента стека
	mov	ax,ss		; (42)
	mov	dl,0		; (43) Та же процедура умножения
	shld	dx,ax,4		; (44) сегментного адреса на 16
	shl	ax,4		; (45) сдвигом влево на 4 бита
	mov	bx,offset gdt_code; (46) BX=адрес дескриптора
	mov	[bx].base_l,ax	; (47) Загрузка младшей
	mov	[bx].base_m,dl	; (48) и средней частей базы
; Подготовим псевдодескриптор pdescr  загрузим регистр GDTR
	mov	bx,offset gdt_data	; (49) Адрес GDT
	mov	ax,[bx].base_l		; (50) Получим и занесём в pdescr
	mov	word ptr pdescr+2,ax	; (51) базу, биты 0...15
	mov	dl,[bx].base_m		; (52) Получим и занесём в pdescr
	mov	byte ptr pdescr+4,dl	; (53) базу, биты 16...23
	mov	word ptr pdescr,gdt_size-1; (54) Граница GDT
	lgdt	pdescr			; (55) Загрузим регистр GDTR
; Подготовимся к возврату из защищённого режима в реальный
	mov	ax,40h		; (56) Настроим ES на область
	mov	es,ax		; (57) данных BIOS
	mov	word ptr es:[67h],offset return; (58) смещение точки возврата
	mov	es:[69h],cs	; (59) Сегмент точки возврата
; Подготовимся к переходу в защищённый режим
	cli			; (60) Запрет аппаратных прерываний
	mov	al,8Fh		; (61) Запрет NMI (80h) и выборка
				; байта состояния отключения 0Fh
	out	70h,al		; (62) Порт КМОП-микросхем
	jmp	$+2		; (63) Задержка
	mov	al,0Ah		; (64) Установим режим восстановления
	out	71h,al		; (65) после сброса процессора
; Переходим в защищённый режим
	smsw	ax		; (66) Получим слово состояния машины
	or	ax,1		; (67) Установим бит PE
	lmsw	ax		; (68) Запишем назад слово состояния
; Теперь процессор работает в защищённом режиме
; Загружаем в CS:IP селектор:смещение точки continue
; и заодно очищаем очередь команд
	db	0EAh		; (69) Код команды far jmp
	dw	offset continue	; (70) Смещение
	dw	16		; (71) Селектор сегмента команд
continue:
; Делаем адресуемыми данные
	mov	ax,8		; (73) Селектор сегмента данных
	mov	ds,ax		; (74)
; Делаем адресуемым стек
	mov	ax,24		; (75) Селектор сегмента стека
	mov	ss,ax		; (76)
; Инициализируем ES и выводим символы
	mov	ax,32		; (77) Селектор сегмента видеобуфера
	mov	es,ax		; (78)
	mov	bx,800		; (79) Начальное смещение на экране
	mov	cx,640		; (80) Число выводимых символов
	mov	ax,word ptr sym	; (81) Начальный символ с атрибутом
screen:	mov	es:[bx], ax	; (82) Вывод в видеобуфер
	add	bx,2		; (83) Сместится в видеобуфере
	inc	ax		; (84) Следующий символ
	loop	screen		; (85) Цикл вывода на экран
; Вернёмся в реальный режим
	mov	real_sp,SP	; (86) Сохраним SP
	mov	al,0FEh		; (87) Команда сброса процессора
	out	64h,AL		; (88) в порт 64h
	hlt			; (89) Останов процессора до окончания сброса
; Теперь процессор снова работает в реальном режиме
; Восстановим операционную среду реального режима
return:	mov	ax,data		; (90) Восстановим адресуемость
	mov	ds,ax		; (91) данных
	mov	sp,real_sp	; (92) Восстановим
	mov	ax,stk		; (93) адресуемость
	mov	ss,ax		; (94) стека
; Разрешим аппаратные и немаскируемые прерывания
	sti			; (95) Разрешение прерываний
	mov	al,0		; (96) Сброс 7 бита в 7 порте CMOS-
	out	70h,al		; (97) разрешение NMI
; Проверим выполнение функций DOS после возврата в реальный режим
	mov	ax,09h		; (98) Функция вывода на экран строки
	mov	dx,offset mes	; (99) Адрес строки
	int	21h		; (100) Вызов DOS
	mov	ax,4C00h	; (101) Завершим программу обычным
	int	21h		; (102) образом
main	endp			; (103) Конец сегмента команд
code_size=$-main		; (104) Размер сегмента команд
text	ends			; (105) Конец сегмента команд

stk	segment	stack 'stack'	; (106) Начало сегмента стека
	db	256 dup ('^')	; (107)
stk	ends			; (108) Конец сегмента стека
	end	main		; (109) Конец программы
