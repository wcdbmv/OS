.386P				; (1)
; Структура для описания дескрипторов сегментов
descr	struc			; (2) Начало объявления структуры
lim	dw	0		; (3) Граница (биты 0…15)
base_l	dw	0		; (4) База, биты 0…15
base_m	db	0		; (5) База, биты 16…23
attr_1	db	0		; (6) Байт атрибутов 1
attr_2	db	0		; (7) Граница (биты 16…19) и атрибуты 2
base_h	db	0		; (8) База, биты 24…31
descr	ends			; (9) Конец объявления структуры
; Сегмент данных
data	segment	use16		; (10) 16-разрядный сегмент
; Таблица глобальных дескрипторов GDT
gdt_null descr<0,0,0,0,0,0>		; (11) Селектор 0, нулевой дескриптор
gdt_data descr<data_size-1,0,0,92h,0,0>	; (12) Селектор 8, сегмент данных
gdt_code descr<code_size-1,0,0,98h,0,0>	; (13) Селектор 16, сегмент команд
gdt_stack descr<255,0,0,92h,0,0>	; (14) Селектор 24, сегмент стека
gdt_screen descr<4095,8000h,0Bh,92h,0,0>; (15) Селектор 32, видеопамять
gdt_size=$-gdt_null		; (16) Размер GDT
; Различные данные программы
pdescr	df	0		; (17) Псевдодескриптор для команды lgdt
sym	db	1		; (18) Символ для вывода на экран
attr	db	1Eh		; (19) Его атрибут
mes	db	27,'[31;42m  Вернулись в реальный режим!  ',27,'[0m$'; (20)
data_size=$-gdt_null		; (21) Размер сегмента данных
data	ends			; (22)
; Сегмент команд
text	segment	'code' use16	; (23) 16-разрядный
	assume	cs:text,ds:data	; (24)
main	proc			; (25)
	xor	eax,eax		; (26) Очистим EAX
	mov	ax,data		; (27) Загрузим в DS сегментный
	mov	ds,ax		; (28) адрес сегмента данных
; Вычислим 32-битовый линейный адрес сегмента данных и загрузим его
; в дескриптор сегмента данных в таблице глобальных дескрипторов GDT.
	shl	eax,4		; (29) EAX=линейный базовый адрес
	mov	ebp,eax		; (30) Сохраним его в EBP для будущего
	mov	bx,offset gdt_data; (31) BX=смещение дескриптора
	mov	[bx].base_l,ax	; (32) Загрузим младшую часть базы
	shr	eax,16		; (33) Старшую половину EAX в AX
	mov	[bx].base_m,al	; (34) Загрузим среднюю часть базы
; Вычислим и загрузим в GDT линейный адрес сегмента команд
	xor	eax,eax		; (35) Очистим EAX
	mov	ax,cs		; (36) Сегментный адрес сегмента команд
	shl	eax,4		; (37)
	mov	bx,offset gdt_code; (38)
	mov	[bx].base_l,ax	; (39)
	shr	eax,16		; (40)
	mov	[bx].base_m,al	; (41)
; Вычислим и загрузим в GDT линейный адрес сегмента стека
	xor	eax,eax		; (42) Очистим EAX
	mov	ax,ss		; (43) Сегментный адрес сегмента стека
	shl	eax,4		; (44)
	mov	bx,offset gdt_stack; (45)
	mov	[bx].base_l,ax	; (46)
	shr	eax,16		; (47)
	mov	[bx].base_m,al	; (48)
; Подготовим псевдодескриптор pdescr  загрузим регистр GDTR
	mov	dword ptr pdescr+2,ebp		; (49) база GDT
	mov	word ptr pdescr,gdt_size-1	; (50) Граница GDT
	lgdt	pdescr				; (51) Загрузим регистр GDTR
; Подготовимся к возврату из защищённого режима в реальный
	mov	ax,40h		; (52) Настроим ES на область
	mov	es,ax		; (53) данных BIOS
	mov	word ptr es:[67h],offset return; (54) смещение точки возврата
	mov	es:[69h],cs	; (55) Сегмент точки возврата
	mov	al,0Fh		; (56) Выборка байта состояния отключения
	out	70h,al		; (57) Порт КМОП-микросхемы
	mov	al,0Ah		; (58) Установка режима восстановления
	out	71h,al		; (59) в регистре 0Fh сброса процессора
	cli			; (60) Запрет аппаратных прерываний
; Переходим в защищённый режим
	mov	eax,cr0		; (61) Получим содержимое регистра CR0
	or	eax,1		; (62) Установим бит защищённого режима
	mov	cr0,eax		; (63) Запишем назад в CR0
;-----------------------------------------------;
; Теперь процессор работает в защищённом режиме ;
;-----------------------------------------------;
; Загружаем в CS:IP селектор:смещение точки continue
	db	0EAh		; (64) Код команды far jmp
	dw	offset continue	; (65) Смещение
	dw	16		; (66) Селектор сегмента команд
continue:			; (67)
; Делаем адресуемыми данные
	mov	ax,8		; (68) Селектор сегмента данных
	mov	ds,ax		; (69)
; Делаем адресуемым стек
	mov	ax,24		; (70) Селектор сегмента стека
	mov	ss,ax		; (71)
; Инициализируем ES
	mov	ax,32		; (72) Селектор сегмента видеобуфера
	mov	es,ax		; (73) Инициализируем ES
; Выводим на экран тестовую строку символов
	mov	di,1920		; (74) Начальное смещение на экране
	mov	cx,80		; (75) Число выводимых символов
	mov	ax,word ptr sym	; (76) Символ + атрибут
scrn:	stosw			; (77) Содержимое AX на экран
	inc	al		; (78) Инкремент кода символа
	loop	scrn		; (79) Цикл вывода
; Вернёмся в реальный режим
	mov	al,0FEh		; (80) Команда сброса процессора
	out	64h,AL		; (81) в порт 64h
	hlt			; (82) Останов процессора до окончания сброса
;---------------------------------------------------;
; Теперь процессор снова работает в реальном режиме ;
;---------------------------------------------------;
return:				; (83)
; Восстановим операционную среду реального режима
	mov	ax,data		; (84) Сделаем адресуемыми данные
	mov	ds,ax		; (85)
	mov	ax,stk		; (86) Сделаем адресуемым стек
	mov	ss,ax		; (87)
	mov	sp,256		; (88) Настроим SP
	sti			; (89) Разрешение аппаратные прерываний
; Работаем в DOS
	mov	ax,09h		; (90) Проверим выполнение функций DOS
	mov	dx,offset mes	; (91) после возврата в реальный режим
	int	21h		; (92)
	mov	ax,4C00h	; (93) Завершим программу обычным образом
	int	21h		; (94)
main	endp			; (95)
code_size=$-main		; (96) Размер сегмента команд
text	ends			; (97)
; Сегмент стека
stk	segment	stack 'stack' use16; (98) 16-разрядный
	db	256 dup ('^')	; (99)
stk	ends			; (100)
	end	main		; (101)
