.386P				; (1) Разрешение команд МП 386 и 486
; Структура для описания дескрипторов сегментов
descr	struc			; (2)
limit	dw	0		; (3) Граница (биты 0...15)
base_l	dw	0		; (4) База, биты 0...15
base_m	db	0		; (5) База, биты 16...23
attr_1	db	0		; (6) Байт атрибутов 1
attr_2	db	0		; (7) Граница (биты 16...19) и атрибуты 2
base_h	db	0		; (8) База, биты 24...31
descr	ends			; (9)

data	segment	use16		; (10) Начало сегмента данных
; Таблица глобальных дескрипторов GDT
gdt_null descr<0,0,0,0,0,0>		; (11) Нулевой дескриптор
gdt_data descr<data_size-1,0,0,92h>	; (12) Сел-р 8, сегмент данных
gdt_code descr<code_size-1,,,98h>	; (13) Селектор 16, сегмент команд
gdt_stack descr<255,0,0,92h,0,0>	; (14) Селектор 24, сегмент стека
gdt_screen descr<4095,8000h,0Bh,92h,0,0>; (15) Селектор 32, видеобуфер
gdt_size=$-gdt_null		; (16) Размер GDT
; Поля данных программы
pdescr	df	0		; (17) Псевдодескриптор для lgdt
sym	db	1		; (18) Символ для вывода на экран
attr	db	1Eh		; (19) Его атрибут
mes	db	27,'[31;42m Вернулись в реальный режим! ',27,'[0m$'; (20)
data_size=$-gdt_null		; (21) Размер сегмента данных
data	ends			; (22) Конец сегмента данных

text	segment	'code' use16	; (23) Укажем 16-разрядный режим
	assume	cs:text,ds:data	; (24)
main	proc			; (25)
	xor	eax, eax	; (26) Очистим EAX
	mov	ax,data		; (27) Загрузим в DS сегментный
	mov	ds,ax		; (28) адрес сегмента данных
; Вычислим 32-битовый линейный адрес сегмента данных и загрузим его
; в дескриптор сегмента данных в GDT.
	shl	eax,4		; (29) В EAX линейный базовый адрес
	mov	ebp,eax		; (30) Сохраним его в EBP
	mov	bx,offset gdt_data; (31) В BX адрес дескриптора
	mov	[bx].base_l,ax	; (32) Загрузим младшую часть базы
	rol	eax,16		; (33) Обмен старшей и младшей половин EAX
	mov	[bx].base_m,al	; (34) Загрузим среднюю часть базы
; Аналогично для линейного адреса сегмента команд
	xor	eax,eax		; (35) Очистим EAX
	mov	ax,cs		; (36) Адрес сегмента команд
	shl	eax,4		; (37) Умножим на 16
	mov	bx,offset gdt_code; (38) Адрес дескриптора
	mov	[bx].base_l,ax	; (39) Загрузим младшую часть базы
	rol	eax,16		; (40) Обмен половин EAX
	mov	[bx].base_m,al	; (41) загрузим среднюю часть базы
; Аналогично для линейного адреса сегмента стека
	xor	eax,eax		; (42)
	mov	ax,ss		; (43)
	shl	eax,4		; (44)
	mov	bx,offset gdt_stack; (45)
	mov	[bx].base_l,ax	; (46)
	rol	eax,16		; (47)
	mov	[bx].base_m,al	; (48)
; Подготовим псевдодескриптор pdescr и загрузим регистр GDTF
	mov	dword ptr pdescr+2,ebp		; (49) База GDT, биты 0...31
	mov	word ptr pdescr,gdt_size-1	; (50) Граница GDT
	lgdt	pdescr				; (51) Загрузим регистр GDTR
; Подготовимся к переходу в защищённый режим
	cli			; (52) Запрет аппаратных прерываний
	mov	al,80h		; (53) Запрет NMI
	out	70h,al		; (54) Порт КМОП-микросхемы
; Переходим в защищённый режим
	mov	eax,cr0		; (55) Получим содержимое CR0
	or	eax,1		; (56) Установим бит PE
	mov	cr0,eax		; (57) Запишем назад в CR0
; Теперь процессор работает в защищённом режиме
; Загружаем в CS:IP селектор:смещение точки continue
; и заодно очищаем очередь команд
	db	0EAh		; (58) Код команды far jmp
	dw	offset continue	; (59) Смещение
	dw	16		; (60) Селектор сегмента команд
continue:			; (61)
; Делаем адресуемыми данные
	mov	ax,8		; (62) Селектор сегмента данных
	mov	ds,ax		; (63)
; Делаем адресуемым стек
	mov	ax,24		; (64) Селектор сегмента стека
	mov	ss,ax		; (65)
; Инициализируем ES и выводим символы
	mov	ax,32		; (66) Селектор сегмента видеобуфера
	mov	es,ax		; (67)
	mov	bx,800		; (68) Начальное смещение на экране
	mov	cx,640		; (69) Число выводимых символов
	mov	ax,word ptr sym	; (70) Начальный символ с атрибутом
screen:	mov	es:[bx], ax	; (71) Вывод в видеобуфер
	add	bx,2		; (72) Сместится в видеобуфере
	inc	ax		; (73) Следующий символ
	loop	screen		; (74) Цикл вывода на экран
; Подготовим переход в реальный режим
; Сформируем и загрузим дескрипторы для реального режима
	mov	gdt_data.limit,0FFFFh	; (75) Граница сегмента данных
	mov	gdt_code.limit,0FFFFh	; (76) Граница сегмента команд
	mov	gdt_stack.limit,0FFFFh	; (77) Граница сегмента стека
	mov	gdt_screen.limit,0FFFFh	; (78) Граница дополнительного сегмента
	mov	ax,8		; (79) Загрузим теневой регистр
	mov	ds,ax		; (80) сегмента данных
	mov	ax,24		; (81) Загрузим теневой регистр
	mov	ss,ax		; (82) стека
	mov	ax,32		; (83) Загрузим теневой регистр
	mov	es,ax		; (84) дополнительного сегмента
; Выполним дальний переход для того, чтобы заново загрузить
; селектор в регистр CS и модифицировать его теневой регистр
	db	0EAh		; (85) Командой дальнего перехода
	dw	offset go	; (86) загрузим теневой регистр
	dw	16		; (87) сегмента команд
; Переключим режим процессора
go:	mov	eax,cr0		; (88) Получим содержимое CR0
	and	eax,0FFFFFFFEh	; (89) Сбросим бит PE
	mov	cr0,eax		; (90) Запишем назад в CR0
	db	0EAh		; (91) Код команды far jmp
	dw	offset return	; (92) Смещение
	dw	text		; (93) Сегмент
; Теперь процессор снова работает в реальном режиме
; Восстановим операционную среду реального режима
return:	mov	ax,data		; (94) Восстановим
	mov	ds,ax		; (95) адресуемость данных
	mov	ax,stk		; (96) Восстановим
	mov	ss,ax		; (97) адресуемость стека
; Разрешим аппаратные и немаскируемые прерывания
	sti			; (98) Разрешение прерываний
	mov	al,0		; (99) Сброс бита 7 в порте CMOS —
	out	70h,al		; (100) — разрешение NMI
; Проверим выполнение функций DOS после возврата в реальный режим
	mov	ah,09h		; (101)
	mov	dx,offset mes	; (102)
	int	21h		; (103)
	mov	ax,4C00h	; (104) Завершим программу
	int	21h		; (105) обычным образом
main	endp			; (106)
code_size=$-main		; (107) Размер сегмента команд
text	ends			; (108)

stk	segment	stack 'stack'	; (109)
	db	256 dup('^')	; (110)
stk	ends			; (111)
	end	main		; (112)
