; Программу нужно запускать из DOS

; Так как вы вряд ли установите DOS, используйте DOSBox (https://www.dosbox.com/download.php?main=1)
; Его можно установить куда угодно (на Linux, Win 10, 7, на виртуальную машину с Win XP)
; Компилятор MASM.EXE (32 разрядный) и компоновщик LINK.EXE
; взять из курса МЗЯП (Машинно-зависимых языков программирования) 4 семестра

;;;;;;;; Зайти в DOSBox, смонтировать диск
; mount C C:\<путь-до-директории-с-исходником>
;;;;;;;; скомпилировать программу
; MASM.EXE main_v.asm,prog.obj,,;
; LINK.EXE prog.obj,,,;
;;;;;;;; Запустить программу
; PROG.EXE

;;;;;;;; Ещё один способ скомпилировать программу:
; build.bat main_v

; Исходник с комментариями взят из примера 62.1 книги Рудакова Финогенова
; "Программируем на языке ассемблера IBM PC" (1997 год, 2 издание)
; (http://libgen.is/search.php?req=Программируем+на+языке+ассемблера)
; и дополнен выводом поясняющих сообщений в видеобуфер

.386P						; (1) Разрешение команд МП 386 и 486
; Структура для описания дескрипторов сегментов
descr	struc					; (2)
	limit	dw	0			; (3) Граница (биты 0...15)
	base_l	dw	0			; (4) База, биты 0...15
	base_m	db	0			; (5) База, биты 16...23
	attr_1	db	0			; (6) Байт атрибутов 1
	attr_2	db	0			; (7) Граница (биты 16...19) и атрибуты 2
	base_h	db	0			; (8) База, биты 24...31
descr	ends					; (9)

data	segment	use16				; (10) Начало сегмента данных
; Таблица глобальных дескрипторов GDT
	gdt_null descr<>			; (11) Нулевой дескриптор
	gdt_data descr<data_size-1,,,92h>	; (12) Сел-р 8, сегмент данных
	gdt_code descr<code_size-1,,,98h>	; (13) Селектор 16, сегмент команд
	gdt_stack descr<255,,,92h>		; (14) Селектор 24, сегмент стека
	gdt_screen descr<4095,8000h,0Bh,92h>	; (15) Селектор 32, видеобуфер
	gdt_data32 descr<0FFFFh,,,92h,0CFh>
gdt_size=$-gdt_null				; (16) Размер GDT
; Поля данных программы
	pdescr	df	0			; (17) Псевдодескриптор для lgdt
	msg_rm	db	'Processor works in real mode     '
msg_rm_len=$-msg_rm
	msg_pm	db	'Processor works in protected mode'
msg_pm_len=$-msg_pm
data_size=$-gdt_null				; (21) Размер сегмента данных
data	ends					; (22) Конец сегмента данных

print	macro	msg,msg_len,row,col,color
	local	screen
	mov	di,row*160 + col*2
	mov	bx,offset msg
	mov	cx,msg_len
	mov	ah,color
screen:	mov	al,byte ptr [bx]
	inc	bx
	stosw
	loop	screen
endm

text	segment	'code' use16			; (23) Укажем 16-разрядный режим
	assume	cs:text,ds:data			; (24)
main	proc					; (25)
	mov	ax,data
	mov	ds,ax
	mov	ax,0B800h
	mov	es,ax

	print	msg_rm,msg_rm_len,11,23,0F0h

	xor	eax,eax				; (26) Очистим EAX
	mov	ax,data				; (27) Загрузим в DS сегментный
;	mov	ds,ax				; (28) адрес сегмента данных
; Вычислим 32-битовый линейный адрес сегмента данных и загрузим его
; в дескриптор сегмента данных в GDT.
	shl	eax,4				; (29) В EAX линейный базовый адрес
	mov	ebp,eax				; (30) Сохраним его в EBP
	mov	bx,offset gdt_data; (31) В BX адрес дескриптора
	mov	[bx].base_l,ax			; (32) Загрузим младшую часть базы
	rol	eax,16				; (33) Обмен старшей и младшей половин EAX
	mov	[bx].base_m,al			; (34) Загрузим среднюю часть базы
; Аналогично для линейного адреса сегмента команд
	xor	eax,eax				; (35) Очистим EAX
	mov	ax,cs				; (36) Адрес сегмента команд
	shl	eax,4				; (37) Умножим на 16
	mov	bx,offset gdt_code; (38) Адрес дескриптора
	mov	[bx].base_l,ax			; (39) Загрузим младшую часть базы
	rol	eax,16				; (40) Обмен половин EAX
	mov	[bx].base_m,al			; (41) загрузим среднюю часть базы
; Аналогично для линейного адреса сегмента стека
	xor	eax,eax				; (42)
	mov	ax,ss				; (43)
	shl	eax,4				; (44)
	mov	bx,offset gdt_stack		; (45)
	mov	[bx].base_l,ax			; (46)
	rol	eax,16				; (47)
	mov	[bx].base_m,al			; (48)
; Подготовим псевдодескриптор pdescr и загрузим регистр GDTF
	mov	dword ptr pdescr+2,ebp		; (49) База GDT, биты 0...31
	mov	word ptr pdescr,gdt_size-1	; (50) Граница GDT
	lgdt	pdescr				; (51) Загрузим регистр GDTR
; Подготовимся к переходу в защищённый режим
	cli					; (52) Запрет аппаратных прерываний
	mov	al,80h				; (53) Запрет NMI
	out	70h,al				; (54) Порт КМОП-микросхемы
; Переходим в защищённый режим
	mov	eax,cr0				; (55) Получим содержимое CR0
	or	eax,1				; (56) Установим бит PE
	mov	cr0,eax				; (57) Запишем назад в CR0
; Теперь процессор работает в защищённом режиме
; Загружаем в CS:IP селектор:смещение точки continue
; и заодно очищаем очередь команд
	db	0EAh				; (58) Код команды far jmp
	dw	offset continue			; (59) Смещение
	dw	16				; (60) Селектор сегмента команд
continue:					; (61)
; Делаем адресуемыми данные
	mov	ax,8				; (62) Селектор сегмента данных
	mov	ds,ax				; (63)
; Делаем адресуемым стек
	mov	ax,24				; (64) Селектор сегмента стека
	mov	ss,ax				; (65)
; Инициализируем ES и выводим символы
	mov	ax,32				; (66) Селектор сегмента видеобуфера
	mov	es,ax				; (67)

	mov	ax,40
	mov	gs,ax

	print	msg_pm,msg_pm_len,12,23,9Fh

; Подготовим переход в реальный режим
; Сформируем и загрузим дескрипторы для реального режима
	mov	gdt_data.limit,0FFFFh		; (75) Граница сегмента данных
	mov	gdt_code.limit,0FFFFh		; (76) Граница сегмента команд
	mov	gdt_stack.limit,0FFFFh		; (77) Граница сегмента стека
	mov	gdt_screen.limit,0FFFFh		; (78) Граница дополнительного сегмента
	mov	ax,8				; (79) Загрузим теневой регистр
	mov	ds,ax				; (80) сегмента данных
	mov	ax,24				; (81) Загрузим теневой регистр
	mov	ss,ax				; (82) стека
	mov	ax,32				; (83) Загрузим теневой регистр
	mov	es,ax				; (84) дополнительного сегмента
; Выполним дальний переход для того, чтобы заново загрузить
; селектор в регистр CS и модифицировать его теневой регистр
	db	0EAh				; (85) Командой дальнего перехода
	dw	offset go			; (86) загрузим теневой регистр
	dw	16				; (87) сегмента команд
; Переключим режим процессора
go:	mov	eax,cr0				; (88) Получим содержимое CR0
	and	eax,0FFFFFFFEh			; (89) Сбросим бит PE
	mov	cr0,eax				; (90) Запишем назад в CR0
	db	0EAh				; (91) Код команды far jmp
	dw	offset return			; (92) Смещение
	dw	text				; (93) Сегмент
; Теперь процессор снова работает в реальном режиме
; Восстановим операционную среду реального режима
return:	mov	ax,data				; (94) Восстановим
	mov	ds,ax				; (95) адресуемость данных
	mov	ax,stk				; (96) Восстановим
	mov	ss,ax				; (97) адресуемость стека
; Разрешим аппаратные и немаскируемые прерывания
	sti					; (98) Разрешение прерываний
	mov	al,0				; (99) Сброс бита 7 в порте CMOS —
	out	70h,al				; (100) — разрешение NMI

	print	msg_rm,msg_rm_len,13,23,0CFh

	mov	ax,4C00h			; (104) Завершим программу
	int	21h				; (105) обычным образом
main	endp					; (106)
code_size=$-main				; (107) Размер сегмента команд
text	ends					; (108)

stk	segment	stack 'stack'			; (109)
	db	256 dup('^')			; (110)
stk	ends					; (111)
	end	main				; (112)
